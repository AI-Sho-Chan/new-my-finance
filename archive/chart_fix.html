<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>チャート表示修正デモ（単一HTML）</title>
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans JP', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; background:#0f172a; color:#e5e7eb; }
      .wrap { max-width: 1080px; margin: 0 auto; padding: 16px; }
      h1 { font-size: 20px; margin: 8px 0 16px; color:#f1f5f9; }
      .toolbar { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
      .toolbar button { background:#334155; color:#cbd5e1; border:none; padding:6px 10px; border-radius:6px; cursor:pointer; }
      .toolbar button.active { background:#4f46e5; color:#fff; }
      .card { background:#0b1220; border:1px solid #1f2937; border-radius:10px; padding:12px; box-shadow: 0 4px 16px rgba(0,0,0,.25); }
      #chart { width: 100%; height: 420px; }
      .note { font-size:12px; color:#9ca3af; margin-top:8px; }
      a { color:#93c5fd; }
    </style>
    <!-- 重要: ブラウザで使う場合は standalone ビルドを読み込む -->
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js" defer></script>
  </head>
  <body>
    <div class="wrap">
      <h1>軽量チャート（Candlestick + MA + BB + 出来高）</h1>
      <div class="card">
        <div class="toolbar" id="tf-toolbar">
          <span>足種:</span>
          <button data-tf="D" class="active">日足</button>
          <button data-tf="W">週足</button>
          <button data-tf="M">月足</button>
        </div>
        <div id="chart"></div>
        <div class="note">注: ライブラリは standalone 版を <code>script</code> で読み込み、ロード後に <code>LightweightCharts.createChart(...)</code> を呼び出しています。ウィンドウ幅に合わせて自動リサイズします。</div>
      </div>
    </div>

    <script>
      // DOM とライブラリの両方が読み込まれてから初期化
      window.addEventListener('DOMContentLoaded', () => {
        // defer で読み込んでいるため、ここでは LightweightCharts が使える
        if (!window.LightweightCharts || !window.LightweightCharts.createChart) {
          console.error('LightweightCharts が読み込まれていません');
          return;
        }

        const { createChart, CrosshairMode, LineStyle } = window.LightweightCharts;
        const container = document.getElementById('chart');
        const toolbar = document.getElementById('tf-toolbar');
        let timeframe = 'D'; // 'D' | 'W' | 'M'

        // チャートを作成
        const chart = createChart(container, {
          width: container.clientWidth,
          height: container.clientHeight || 420,
          layout: { background: { type: 0, color: 'transparent' }, textColor: '#cbd5e1' },
          grid: { vertLines: { color: '#253041' }, horzLines: { color: '#253041' } },
          crosshair: { mode: CrosshairMode.Normal },
          rightPriceScale: { borderColor: '#334155' },
          timeScale: { borderColor: '#334155' },
        });

        // 重要: createChart の戻り値はチャート API（オブジェクト）
        // addCandlestickSeries はこのオブジェクトのメソッドです
        const candle = chart.addCandlestickSeries({
          upColor: '#10b981', downColor: '#ef4444',
          wickUpColor: '#10b981', wickDownColor: '#ef4444',
          borderUpColor: '#10b981', borderDownColor: '#ef4444',
        });
        const volume = chart.addHistogramSeries({ priceFormat: { type: 'volume' }, priceScaleId: '' });
        volume.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });
        const ma50 = chart.addLineSeries({ color: 'rgba(234,179,8,0.9)', lineWidth: 2 });
        const ma200 = chart.addLineSeries({ color: 'rgba(192,132,252,0.9)', lineWidth: 2, lineStyle: LineStyle.Dotted });
        const bbUpper = chart.addLineSeries({ color: 'rgba(56,189,248,0.6)', lineStyle: LineStyle.Dashed });
        const bbLower = chart.addLineSeries({ color: 'rgba(56,189,248,0.6)', lineStyle: LineStyle.Dashed });

        // ダミーOHLC生成（単一ファイルのため外部APIは使用しない）
        function genData(tf) {
          const out = [];
          const now = new Date(); now.setHours(0,0,0,0);
          const n = tf === 'D' ? 250 : tf === 'W' ? 260 : 240;
          const step = tf === 'D' ? 1 : tf === 'W' ? 7 : 30; // day(s)
          let price = 5000;
          for (let i = n - 1; i >= 0; i--) {
            const d = new Date(now); d.setDate(now.getDate() - i * step);
            const open = price;
            const move = (Math.random() - 0.48) * price * 0.02;
            const close = open + move;
            const high = Math.max(open, close) + Math.random() * 20;
            const low = Math.min(open, close) - Math.random() * 20;
            const vol = Math.random() * 100000 + 50000;
            out.push({ time: Math.floor(d.getTime()/1000), open, high, low, close, value: Math.round(vol) });
            price = close;
          }
          return out;
        }

        function movingAverage(src, length) {
          const out = []; let sum = 0;
          for (let i = 0; i < src.length; i++) {
            sum += src[i].close; if (i >= length) sum -= src[i - length].close;
            if (i >= length - 1) out.push({ time: src[i].time, value: +(sum / length).toFixed(2) });
          }
          return out;
        }
        function bollinger(src, length = 20, mul = 2) {
          const out = []; const q = []; let sum = 0, sumSq = 0;
          for (let i = 0; i < src.length; i++) {
            const v = src[i].close; q.push(v); sum += v; sumSq += v*v;
            if (q.length > length) { const rm = q.shift(); sum -= rm; sumSq -= rm*rm; }
            if (q.length === length) {
              const mean = sum/length; const variance = sumSq/length - mean*mean; const stdev = Math.sqrt(Math.max(variance,0));
              out.push({ time: src[i].time, upper: +(mean + mul*stdev).toFixed(2), lower: +(mean - mul*stdev).toFixed(2) });
            }
          }
          return out;
        }

        function render(tf) {
          const data = genData(tf);
          candle.setData(data);
          volume.setData(data.map(d => ({ time: d.time, value: d.value, color: d.close >= d.open ? 'rgba(34,197,94,0.5)' : 'rgba(239,68,68,0.5)' })));
          const m50 = movingAverage(data, 50); ma50.setData(m50);
          const m200 = movingAverage(data, 200); ma200.setData(m200);
          const bb = bollinger(data, 20, 2);
          bbUpper.setData(bb.map(x => ({ time: x.time, value: x.upper })));
          bbLower.setData(bb.map(x => ({ time: x.time, value: x.lower })));
          chart.timeScale().fitContent();
        }

        render(timeframe);

        // 足種切替
        toolbar.addEventListener('click', (e) => {
          const btn = e.target.closest('button[data-tf]');
          if (!btn) return;
          timeframe = btn.getAttribute('data-tf');
          [...toolbar.querySelectorAll('button[data-tf]')].forEach(b => b.classList.toggle('active', b === btn));
          render(timeframe);
        });

        // リサイズ対応
        const ro = new ResizeObserver(() => {
          const w = container.clientWidth; const h = container.clientHeight || 420;
          chart.applyOptions({ width: w, height: h });
        });
        ro.observe(container);
        window.addEventListener('beforeunload', () => ro.disconnect());
      });
    </script>
  </body>
  </html>
